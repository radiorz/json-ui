export default {
  // 定义一个input该有的参数
  // 这个key值 比较特殊不用tag表示了
  input: {
    //
    数据改变的生命周期: {
      initialized,
      onInputing, // 要么是拖拽的正在抓则
      oninputEnd,
      onValidating,
      onValidatedEnd,
      onValidatedError,
      事件: {
        focus, // 聚焦 (click或者press)
        validate, // 校验
        change, // 尤其是键盘输入 通常输入不是一蹴而就的 而是慢慢change的，这种要么给个按钮点确认才确认
        blur, //失焦 失焦是一种很好的确认输入完毕的手段
        reset, // 重置
      },
    },
    数据规范与限制: {
      // 也属于输入限制，直接无了
      isDisabled: true, // 禁止输入
      isString: true, // 文字，属于文本输入,文本可以表示一切 幸好有正则表达式可以规范
      // string 是数据的抽象描述，
      string: {
        // 抽象的规则
        pattern, // 正则表达式的规范
        // 具体的限制
        长度, // 文字通常是有长度限制的
        字符限制, //
      },
      // 有限离散的选择
      isSelectByItems: false, // 从对象中选择（单选），单选其实就是选项都互斥，多选就见 array
      selectByItems: {
        // 需要做很多便于选择的优化
        // - 可选项数量少应平铺，
        // - 可选项数量多要有搜索，树图等表示其关系
        // - 可选项要有顺序，
        // 可选项数量： 二选一，列表选择等是数量之间的关系
        // 可选项之间有明显逻辑关系： 普通互斥（二选一），树选择（有层级关系），甚至图选择
        items: [], // 可供选择的对象
      },
      // 数字通常是连续的
      isSelectByRange: false, // 数字等 这种连续的很适合滚动滑动选择,或者加减
      // 离散其实和连续有时也可以相互转换,比如 1,2,3 在自然数中是连续的,但在有理数上是离散的,
      // - 比如日期，本来是时间是连续的，设定了一日这个步长，以及月30天这个max可选项，就变成了 1-30的少量的选项，颜色也是，可以无限变有限，变成7彩色
      // 设置合理的步长,就会让离散变得连续
      // 数字其实和select 很像 但通常item很多很大（数字经常是接近无穷的 select通常是有穷的）
      selectByRange: {
        // item 的选择范围
        range: {
          min,
          max,
        },
        // 其实数字范围也可以用正则进行规范，因为数字也是用字符表示的。
      },
      // 其实就是多选 数据结构就是数组
      // 万物皆可array
      isFile: false, // 文件输入
      file: {
        // 文件的类型千奇百怪也随之很多具体的参数
      },
      // 业务类型
      业务上细分类型的限制: {
        // 字符串是最有活力的，因为所有东西都可以用文字表示
        string: {
          isEmail,
          电话号码,
        },
        // 这个一般就是range上做现职
        // 大部分range都有步长（比如时间通常步长是秒），除非是直接输入数字
        selectByRange: {
          is0_100, // 这个是人文上经常的
          is0_5, // 五星好评
          is0_255, // 这个是机器上经常的
          日期,
          时间, // 时间是连续的
        },
      },
    },
    // 所有的输入都可能是数组 就是相似的项(其实是多个input 的数据联合，是数据间的关系（同类，互斥))
    // 多选和单选也可以互相转换，单选是特殊的多选，多选是重复的单选
    isArray: true,
    array: {
      // 选择的数量
      itemsRange: {
        min,
        max,
      },
      items关系: {
        是否互斥,
        是否拥有顺序,
      },
    },
    经典的数组: {
      isSwitch, // 开关 只有正反两个选择,
      isIp, // 4个0-255数字组成的数组
      选择范围, // 是的，多选尤其是可选性等于2或3的选择通常也可以选择一个范围，比如价格区间，日期区间等等
    },
    // 输入优化通常伴随则显示优化
    输入优化: {
      文件: {
        文件可以拖拽输入,
      },
      字符串的具体业务格式: {
        日期,
        时间,
      },
      具备大小的优化: {
        五星好评的黄与白,
        数字越大显示越大之类的, // 或者说越高越胖反正就直观
      },
      items可选项: {
        switch: false,
        列表,
        可过滤,
        // 最经典就是可键入搜索
        树,
        图map, // 地点选择
        // 本身需要具备国际化 自然语言化的显示
        自然语言化或者叫做本土化,
      },
      range: {
        反正就是连续对连续,
        单位划分,
      },
      选择或者输入本身: {
        可全选,
        可清空,
      },
      与实际设备有关的: {
        isKeyboard: {
          keyboardType: {
            数字,
            文字,
            字母等适合键盘输入的,
          },
        },
        点击选择,
        拖拽选择,
        滚动选择,
        滑动选择,
        长按选择,
        hover超过某个时间选中,
      },
    },
    显示优化: {
      整体的显示与隐藏: {
        notDisplay, // 不显示 默认 初始值空+ disabled 不显示，
        onlyDisplay, // readonly 显示但不能修改 约等于 初始值非空+ disabled（有时候初始值为空也会显示）
        hide: false, // 密码等私密的要隐藏 hide ，hide通常要可切换显示
      },
      // 可选项的优化
      isTreeSelect: false, // 树图选择 这个详见可选项关系
      treeSelect: {
        级联: false,
      },
      //长文本的显示框要大点
      isBigString: false, // 大文本
      提示: {
        // 数据其实只有对错两种,偶尔有那种摸棱两可的就是不建议但可行的,但很少
        info: {
          label, // 提示数据是啥子
          图标, // 图形化的提示比文字等更加直观 warn error 也可以搞图标
          无输入值提示: "请输入",
          string: {
            字数统计,
          },
          number: {
            标注单位, // 比如金钱的标注
          },
        },
        warn: {
          // 比如文本太长了,但还不够长(比如有的问题会小于几个字,没到就可以提醒),可以提前提示一下
          // 就像是列车的黄线，虽然不一定会死，但已经置身险境
        },
        error: {
          校验错误, // 校验是一种另类的限制 当你限制达到完美时，其实就不需要额外校验，也就是 输入不限制
        },
      },
    },
  },
};
const inputs = {
  数据之间的关系: {
    父子关系, // 对象 
    同类关系, // 数组表示即可 同类关系可以合并到一个input上 select more 即可
    大小关系, //
    互相影响, // 比如生日与 年月日，
  },
  // 这个其实
  布局优化: {
    // 布局跟随数据间关系来移动
    对象的父子关系,
    数组的同类关系,
  },
  表单之间: {
    // 填写表单可能是有顺序的，
    // 不过顺序可以用多分表单表示即可，
  },
  输出优化: {
    只上传修改的值,
  },
};
const input = {
  type: "object",
};
//
const output = {};
